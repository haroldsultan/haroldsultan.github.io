<!DOCTYPE html>
<html>
<head>
    <title>SEV Saturation Visualizer</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin-top: 20px;
        }
        .sev-entry {
            margin-bottom: 20px;
        }
        .key {
            margin-top: 20px;
        }
        .key div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .key span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .button-container {
            margin-top: 10px; /* Adjust the margin as needed */
        }
        .csv-upload, .csv-download {
            margin-top: 10px; /* Adjust the margin as needed */
        }
        .csv-upload label {
            display: inline-block;
            margin-bottom: 5px; /* Optional: Adjust margin as needed */
        }

        .csv-upload input[type="file"],
        .csv-upload button {
          vertical-align: middle;
          margin-left: 5px; /* Optional: Adjust margin as needed */
        }
    </style>
</head>
<body>
    <h1>SEV Saturation Visualizer</h1>
    <p>A SEV (Site Event) refers to an unexpected incident or occurrence that can impact projects or features across a company, affecting usability or safety for customers. These events can range from minor disruptions to major accidents or emergencies, often requiring immediate attention and action to mitigate any negative effects.</p>
    <p>Managing ongoing SEVs incurs an engineering maintenance cost on a team. This visualizer and indexing tool are designed to help capture this cost. The measure, SEV Saturation Index (SSI), is a coarse metric intended to capture the maintenance burden that an engineering team faces in responding to SEVs over a period of time.</p>
    <p>The SEV Saturation Index, or SSI, is defined as follows:</p>
    <p style="text-align:center;">
      <img src="https://latex.codecogs.com/svg.latex?\large\text{SSI}=\frac{\sum_{i=0}^{4}(\text{days with open SEV}_i)\times(5-i)}{\text{team size}\times\text{num\_days}\times 5}">
    </p>
    <p>Mileage will vary on a team-by-team basis, but the scaling is such that 0 represents no SEV saturation, and 1.0 would represent "Full" Saturation. Note that there is technically no maximum value for the metric, so supersaturation is possible.</p>
    <p>Notes: There are multiple options for `sev_start` and `sev_end`. Since we are interested in capturing the maintenance burden of SEVs, the recommendation for `sev_start` is biased toward using the time the SEV was created rather than when the incident started, and similarly for `sev_end`, bias is toward using a resolved or mitigated date.</p>
    <h3>Team size</h3>
    <div>
      <label for="team-size">Team Size :</label>
      <input type="number" id="team-size" min="1" value="6">
      <button onclick="updateTeamSize()">Apply</button>
    </div>
    <h3>Add SEVs</h3>
    <div class="csv-upload">
      <label for="csv-file">Upload CSV:</label>
      <input type="file" id="csv-file" accept=".csv">
      <button onclick="uploadCSV()">Upload</button>
      <br>
      <div>
        <text>Just testing, add a random SEV </text>
        <button onclick="addRandomSEV()">Add Random SEV</button>
      </div>
      <br>
      <div class="sev-entry">
        <text>Manually add a SEV</text>
        <label for="sev-level">Severity Level:</label>
        <select id="sev-level">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select><br>
        <label for="start-date">Start Date:</label>
        <input type="date" id="start-date"><br>
        <label for="end-date">End Date:</label>
        <input type="date" id="end-date"><br>
        <button onclick="addSEV()">Add SEV</button>
      </div>
    </div>
    <h3>SEV Saturation limit</h3>
    <div>
      <label for="max-severity">Max Saturation:</label>
      <input type="number" id="max-severity" min="0">
      <button onclick="updateMaxSeverity()">Apply</button>
      <button onclick="clearMaxSeverity()">Clear</button>
    </div>
    <h3>Adjust chart range</h3>
    <div class="date-range">
        <label for="graph-start-date">Graph Start Date:</label>
        <input type="date" id="graph-start-date"><br>
        <label for="graph-end-date">Graph End Date:</label>
        <input type="date" id="graph-end-date"><br>
        <button onclick="drawHeatmap()">Update Visualization Range</button>
    </div>
    <canvas id="heatmap" width="1000" height="150"></canvas>
    <div class="csv-download">
        <button onclick="downloadCSV()">Download Current SEVs as CSV</button>
    </div>
    <div class="key">
        <h3>Severity Saturation level:</h3>
        <div><span style="background-color: rgba(255, 0, 0, 0.5);"></span>>=90% Saturation</div>
        <div><span style="background-color: rgba(255, 165, 0, 0.5);"></span>>=80% Saturation</div>
        <div><span style="background-color: rgba(255, 255, 0, 0.5);"></span>>=70% Saturation</div>
        <div><span style="background-color: rgba(154, 205, 50, 0.5);"></span>>=60% Saturation</div>
        <div><span style="background-color: rgba(0, 128, 0, 0.5);"></span>>=50% Saturation</div>
        <div><span style="background-color: rgba(0, 255, 255, 0.5);"></span>>=40% Saturation</div>
        <div><span style="background-color: rgba(0, 191, 255, 0.5);"></span>>=30% Saturation</div>
        <div><span style="background-color: rgba(30, 144, 255, 0.5);"></span>>=20% Saturation</div>
        <div><span style="background-color: rgba(138, 43, 226, 0.5);"></span>>=10% Saturation</div>
        <div><span></span><10% Saturation (Clear)</div>
      </div>
      <br>
      <div>
        <h4>Clear SEVs</h4>
        <button onclick="clearSEVs()">Clear All SEVs</button>
        <br>
      <h4>Table of SEVs</h4>
      <table border="1">
        <thead>
          <tr>
            <th>SEV Level</th>
            <th>Start Date</th>
            <th>End Date</th>
          </tr>
        </thead>
        <tbody id="sevTableBody">
          <!-- Table rows will be dynamically added here -->
        </tbody>
        </table>
      </div>
    <script>
        const SEVs = [];
        const canvas = document.getElementById('heatmap');
        const ctx = canvas.getContext('2d');
        const defaultMaxSeverity = 10;

        function addSEV() {
            const level = document.getElementById('sev-level').value;
            const startDate = new Date(document.getElementById('start-date').value);
            const endDate = new Date(document.getElementById('end-date').value);

            if (startDate >= endDate) {
                alert("Start date must be before end date");
                return;
            }

            SEVs.push({ level, startDate, endDate });
            drawHeatmap();
        }
        let maxSeverityDynamic = true
        let maxSeverity = defaultMaxSeverity;
        let teamSize = 1;

        function buildSeverityMap(){
          let severityMap = new Map(); // Map to track cumulative severity per date
          // Populate severityMap with cumulative severity for each date
          SEVs.forEach(sev => {
              const startDate = sev.startDate;
              const endDate = sev.endDate;
              const severityLevel = parseInt(sev.level);

              // Iterate through each date within the SEV range
              for (let date = startDate.getTime(); date <= endDate.getTime(); date += 24 * 60 * 60 * 1000) {
                  const currentDate = new Date(date);
                  const dateString = currentDate.toISOString().split('T')[0]; // Get YYYY-MM-DD format

                  // Initialize cumulative severity for this date if not already initialized
                  if (!severityMap.has(dateString)) {
                      severityMap.set(dateString, 0);
                  }

                  // Add current SEV's severity level to cumulative severity for this date
                  severityMap.set(dateString, severityMap.get(dateString) + severityLevel);
              }
          });
          return severityMap;
        }

        function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Function to generate random SEV data
        function addRandomSEV() {
            var levels = ["0", "1", "2", "3", "4"];
            let startTimestamp, endTimestamp;

            const graphStartDateInput = document.getElementById('graph-start-date').value;
            const graphEndDateInput = document.getElementById('graph-end-date').value;

            if (graphStartDateInput && graphEndDateInput) {
                startTimestamp = new Date(graphStartDateInput).getTime();
                endTimestamp = new Date(graphEndDateInput).getTime();
            } else {
                const now = new Date();
                startTimestamp = new Date(now - 180 * 24 * 60 * 60 * 1000).getTime();
                endTimestamp = now.getTime();
            }

            var randomTimestamp1 = startTimestamp + Math.random() * (endTimestamp - startTimestamp);
            var randomDate1 = new Date(randomTimestamp1);

            var randomTimestamp2 = randomTimestamp1 + getRandomInt(2, 14) * 24 * 60 * 60 * 1000;
            var randomDate2 = new Date(randomTimestamp2);

            var newSEV = {
                level: levels[getRandomInt(0, levels.length - 1)],
                startDate: randomDate1,
                endDate: randomDate2,
            };

            SEVs.push(newSEV); // Add the new SEV to the SEVs array
            drawHeatmap(); // Update the table with the new SEV data
        }

        function setMaxSeverity(severityMap){
          // Find the maximum cumulative severity across all dates
          if (maxSeverityDynamic) {
            severityMap.forEach(severity => {
              if (severity > maxSeverity) {
                  maxSeverity = severity;
              }
            })
          };
        }

        function drawHeatmap() {
          console.log(SEVs);
          const canvas = document.getElementById('heatmap');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          let startTime, endTime;

          const graphStartDateInput = document.getElementById('graph-start-date').value;
          const graphEndDateInput = document.getElementById('graph-end-date').value;

          if (graphStartDateInput && graphEndDateInput) {
              startTime = new Date(graphStartDateInput);
              endTime = new Date(graphEndDateInput);
          } else {
              const now = new Date();
              startTime = new Date(now - 180 * 24 * 60 * 60 * 1000);
              endTime = now;
          }
          const timeSpan = endTime.getTime() - startTime.getTime();

          let severityMap = buildSeverityMap();
          setMaxSeverity(severityMap);

          // Draw the heatmap based on severityMap
          severityMap.forEach((cumulativeSeverity, dateString) => {
              const currentDate = new Date(dateString);
              const xStart = Math.floor(((currentDate - startTime) / timeSpan) * canvas.width);
              // Calculate width of the segment based on time span
              let width;
              if (severityMap.size === 1) {
                  width = canvas.width;
              } else {
                  const nextDate = new Date(currentDate);
                  nextDate.setDate(nextDate.getDate() + 1);
                  const xEnd = Math.ceil(((nextDate - startTime) / timeSpan) * canvas.width);
                  width = xEnd - xStart;
              }
              // Calculate severity ratio relative to maxSeverity
              const severityRatio = cumulativeSeverity / maxSeverity;
              // Draw segment on canvas
              const color = getColorByCombinedSeverity(severityRatio);
              ctx.fillStyle = color;
              ctx.fillRect(xStart, 0, width, canvas.height);
          });
          drawXAxis(startTime, endTime);
          drawSSITop();
          populateSEVTable();
        }

        function drawSSITop() {
            const SSI = calculateSEVSaturationIndex();
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`SEV Saturation Index: ${SSI.toFixed(2)}`, canvas.width / 2, 30);
        }

        function calculateSEVSaturationIndex() {
            let totalSeverity = 0;
            let severityMap = buildSeverityMap();
            severityMap.forEach((cumulativeSeverity) => {
                totalSeverity += cumulativeSeverity;
            });

            const graphStartDateInput = document.getElementById('graph-start-date').value;
            const graphEndDateInput = document.getElementById('graph-end-date').value;

            if (graphStartDateInput && graphEndDateInput) {
                startTime = new Date(graphStartDateInput);
                endTime = new Date(graphEndDateInput);
            } else {
                const now = new Date();
                startTime = new Date(now - 180 * 24 * 60 * 60 * 1000);
                endTime = now;
            }
            const timeDifference = Math.abs(endTime - startTime);
            const daysDifference = timeDifference / (1000 * 60 * 60 * 24);
            const sevSaturationIndex = totalSeverity / (teamSize * daysDifference * 5);
            return sevSaturationIndex;
        }

        function updateTeamSize() {
           const teamSizeInput = document.getElementById('team-size').value;
           teamSize = parseInt(teamSizeInput);

           // Redraw the heatmap with updated teamSize
           drawHeatmap();
        }

        function updateMaxSeverity() {
           const maxSeverityInput = document.getElementById('max-severity').value;
           maxSeverity = parseInt(maxSeverityInput);
           maxSeverityDynamic = false;

           // Redraw the heatmap with updated maxSeverity
           drawHeatmap();
        }

        function clearMaxSeverity() {
           maxSeverityDynamic = true;
           maxSeverity = defaultMaxSeverity;
           let severityMap = buildSeverityMap();
           setMaxSeverity(severityMap);

           // Redraw the heatmap with updated maxSeverity
           drawHeatmap();
        }

        function getColorByCombinedSeverity(severityRatio) {
          if (severityRatio >= 0.9) return 'rgba(255, 0, 0, 0.5)';     // Red
          if (severityRatio >= 0.8) return 'rgba(255, 165, 0, 0.5)';   // Orange
          if (severityRatio >= 0.7) return 'rgba(255, 255, 0, 0.5)';   // Yellow
          if (severityRatio >= 0.6) return 'rgba(154, 205, 50, 0.5)';  // Yellow-Green
          if (severityRatio >= 0.5) return 'rgba(0, 128, 0, 0.5)';     // Green
          if (severityRatio >= 0.4) return 'rgba(0, 255, 255, 0.5)';   // Cyan
          if (severityRatio >= 0.3) return 'rgba(0, 191, 255, 0.5)';   // Deep Sky Blue
          if (severityRatio >= 0.2) return 'rgba(30, 144, 255, 0.5)';  // Dodger Blue
          if (severityRatio >= 0.1) return 'rgba(138, 43, 226, 0.5)';  // Blue-Violet
          return 'rgba(128, 0, 128, 0)';                             // Clear
        }


        function clearSEVs() {
            SEVs.length = 0; // Clear the SEVs array
            drawHeatmap();   // Redraw the heatmap to reflect the cleared SEVs
        }

        function drawXAxis(startTime, endTime) {
            ctx.fillStyle = "black";
            ctx.font = "12px Arial";
            const timeSpan = endTime - startTime;
            const numDivisions = 10;
            for (let i = 0; i <= numDivisions; i++) {
                const x = (i / numDivisions) * canvas.width;
                const date = new Date(startTime.getTime() + (i / numDivisions) * timeSpan);
                const dateStr = date.toISOString().split('T')[0];
                ctx.fillText(dateStr, x, canvas.height - 10);
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - 20);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function uploadCSV() {
          const fileInput = document.getElementById('csv-file');
          const file = fileInput.files[0];
          const reader = new FileReader();

          reader.onload = function(e) {
              const text = e.target.result;
              const lines = text.split('\n');
              const header = lines[0].split(',');

              if (header[0].trim() !== 'sev_start' || header[1].trim() !== 'sev_end' || header[2].trim() !== 'severity') {
                  alert('Invalid CSV format. Please ensure the CSV file has headers: sev_start, sev_end, severity');
                  return;
              }

              for (let i = 1; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (line) {
                      const [sev_start, sev_end, severity] = line.split(',');
                      const startDate = new Date(sev_start.trim());
                      let endDate = new Date(sev_end.trim());
                      if (isNaN(endDate.getTime())) {
                        endDate = new Date();
                      }
                      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                          alert(`Invalid date format in line ${i + 1}. Dates must be in YYYY-MM-DD format.`);
                          return;
                      }

                      const level = severity.trim();
                      SEVs.push({ level, startDate, endDate });
                  }
              }

              drawHeatmap(); // Redraw the heatmap after uploading SEVs from CSV
          };

          reader.readAsText(file);
        }

        function downloadCSV() {
          const csvContent = 'sev_start,sev_end,severity\n' +
              SEVs.map(sev => `${sev.startDate.toISOString().split('T')[0]},${sev.endDate.toISOString().split('T')[0]},${sev.level}`).join('\n');
          const blob = new Blob([csvContent], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'sev_data.csv';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
      }
      function populateSEVTable() {
          var tableBody = document.getElementById("sevTableBody");
          tableBody.innerHTML = ''; // Clear existing table rows
          SEVs.forEach(function(sev, index) {
            var row = document.createElement("tr");

            var cellLevel = document.createElement("td");
            cellLevel.textContent = sev.level;
            row.appendChild(cellLevel);

            var cellStartDate = document.createElement("td");
            cellStartDate.textContent = formatDate(sev.startDate);
            row.appendChild(cellStartDate);

            var cellEndDate = document.createElement("td");
            cellEndDate.textContent = formatDate(sev.endDate);
            row.appendChild(cellEndDate);

            tableBody.appendChild(row);

            var cellDelete = document.createElement("td");
            var deleteButton = document.createElement("button");
            deleteButton.textContent = "Delete";
            deleteButton.addEventListener("click", function() {
                deleteSEV(index); // Call function to delete SEV by ID
            });
            cellDelete.appendChild(deleteButton);
            row.appendChild(cellDelete);
          });
        }

        function formatDate(dateString) {
            var date = new Date(dateString);
            var year = date.getFullYear();
            var month = ('0' + (date.getMonth() + 1)).slice(-2); // Adding leading zero if needed
            var day = ('0' + date.getDate()).slice(-2); // Adding leading zero if needed
            return year + '-' + month + '-' + day;
        }

        function deleteSEV(index) {
            console.log("Deleting SEV at index:", index);
            SEVs.splice(index, 1); // Remove SEV from SEVs array
            drawHeatmap();
        }

        window.onload = function() {
            const now = new Date();
            document.getElementById('graph-start-date').value = new Date(now - 180 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            document.getElementById('graph-end-date').value = now.toISOString().split('T')[0];
            drawHeatmap();
        }
    </script>
</body>
</html>
